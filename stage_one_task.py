# -*- coding: utf-8 -*-
"""stage_one_task

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1FabiTafqZEQAfrBGH_zk5gTJOixWn2td
"""

#a function for translating DNA to protein
def dna_to_protein(dna_sequence):
    codon_table = {
        'ATA': 'I', 'ATC': 'I', 'ATT': 'I', 'ATG': 'M',
        'ACA': 'T', 'ACC': 'T', 'ACG': 'T', 'ACT': 'T',
        'AAC': 'N', 'AAT': 'N', 'AAA': 'K', 'AAG': 'K',
        'AGC': 'S', 'AGT': 'S', 'AGA': 'R', 'AGG': 'R',
        'CTA': 'L', 'CTC': 'L', 'CTG': 'L', 'CTT': 'L',
        'CCA': 'P', 'CCC': 'P', 'CCG': 'P', 'CCT': 'P',
        'CAC': 'H', 'CAT': 'H', 'CAA': 'Q', 'CAG': 'Q',
        'CGA': 'R', 'CGC': 'R', 'CGG': 'R', 'CGT': 'R',
        'GTA': 'V', 'GTC': 'V', 'GTG': 'V', 'GTT': 'V',
        'GCA': 'A', 'GCC': 'A', 'GCG': 'A', 'GCT': 'A',
        'GAC': 'D', 'GAT': 'D', 'GAA': 'E', 'GAG': 'E',
        'GGA': 'G', 'GGC': 'G', 'GGG': 'G', 'GGT': 'G',
        'TCA': 'S', 'TCC': 'S', 'TCG': 'S', 'TCT': 'S',
        'TTC': 'F', 'TTT': 'F', 'TTA': 'L', 'TTG': 'L',
        'TAC': 'Y', 'TAT': 'Y', 'TAA': 'Stop', 'TAG': 'Stop', 'TGA': 'Stop'
    }
    protein = ""
    for i in range(0, len(dna_sequence) - 2, 3):  # Read in triplets
        codon = dna_sequence[i:i+3]
        amino_acid = codon_table.get(codon)
        if amino_acid == 'Stop':  # Stop codon
            break
        protein += amino_acid
    return protein
# Example usage:
dna_seq = "ATGGCCATTGTAATGGGCCGCTGAAAGGGTGCCCGATAG"
print(dna_to_protein(dna_seq))
# Output: "MA"

def dna_to_protein(dna_seq):
    """
    Translates a DNA sequence into a protein sequence
    using the standard genetic code.
    """

    # Define codon table for translation
    codon_table = {
        'ATA':'I', 'ATC':'I', 'ATT':'I', 'ATG':'M',
        'ACA':'T', 'ACC':'T', 'ACG':'T', 'ACT':'T',
        'AAC':'N', 'AAT':'N', 'AAA':'K', 'AAG':'K',
        'AGC':'S', 'AGT':'S', 'AGA':'R', 'AGG':'R',
        'CTA':'L', 'CTC':'L', 'CTG':'L', 'CTT':'L',
        'CCA':'P', 'CCC':'P', 'CCG':'P', 'CCT':'P',
        'CAC':'H', 'CAT':'H', 'CAA':'Q', 'CAG':'Q',
        'CGA':'R', 'CGC':'R', 'CGG':'R', 'CGT':'R',
        'GTA':'V', 'GTC':'V', 'GTG':'V', 'GTT':'V',
        'GCA':'A', 'GCC':'A', 'GCG':'A', 'GCT':'A',
        'GAC':'D', 'GAT':'D', 'GAA':'E', 'GAG':'E',
        'GGA':'G', 'GGC':'G', 'GGG':'G', 'GGT':'G',
        'TCA':'S', 'TCC':'S', 'TCG':'S', 'TCT':'S',
        'TTC':'F', 'TTT':'F', 'TTA':'L', 'TTG':'L',
        'TAC':'Y', 'TAT':'Y', 'TAA':'_', 'TAG':'_',
        'TGC':'C', 'TGT':'C', 'TGA':'_', 'TGG':'W',
    }

    # Ensure sequence length is divisible by 3
    protein = ""
    for i in range(0, len(dna_seq) - 2, 3):
        codon = dna_seq[i:i+3]
        amino_acid = codon_table.get(codon, 'X')  # X for unknown/invalid codon
        protein += amino_acid

    return protein


# Example usage:
dna_seq = "ATGGCCATTGTAATGGGCCGCTGAAAGGGTGCCCGATAG"
print("Protein sequence:", dna_to_protein(dna_seq))

def hamming_distance(str1, str2):
    """
    Calculates the Hamming distance between two strings.
    Pads the shorter string with underscores (_) if needed.
    """

    # Pad strings to equal length
    max_len = max(len(str1), len(str2))
    str1 = str1.ljust(max_len, '_')
    str2 = str2.ljust(max_len, '_')

    # Compare character by character
    distance = sum(ch1 != ch2 for ch1, ch2 in zip(str1, str2))
    return distance


# Example usage:
slack_username = "vil"
twitter_handle = "anoonda_v"

print(f"Hamming Distance: {hamming_distance(slack_username, twitter_handle)}")

# ---------- PART A: Gene Expression Analysis ----------
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
import numpy as np

# ========== (a) Heatmap ==========
# Load normalized counts (HBR vs UHR)
expr = pd.read_csv("HBR vs UBR.txt", index_col=0)

# Select top 10 most variable genes for visualization
top_genes = expr.var(axis=1).sort_values(ascending=False).head(10).index
expr_top = expr.loc[top_genes]

# Plot clustered heatmap
plt.figure(figsize=(6, 5))
sns.clustermap(expr_top, cmap="Blues", figsize=(6, 5),
               yticklabels=True, xticklabels=True)
plt.title("Top Differentially Expressed Genes (HBR vs UHR)")
plt.show()


# ========== (b) Volcano Plot ==========
# Load differential expression results
deg = pd.read_csv("chr 22.txt")

# Define significance category
def significance(row):
    if row['log2FoldChange'] >= 1 and row['PAdj'] < 0.05:
        return 'Upregulated'
    elif row['log2FoldChange'] <= -1 and row['PAdj'] < 0.05:
        return 'Downregulated'
    else:
        return 'Not Significant'

deg['Significance'] = deg.apply(significance, axis=1)
deg['-log10Padj'] = -np.log10(deg['PAdj'])

# Volcano plot
plt.figure(figsize=(6,5))
sns.scatterplot(data=deg, x='log2FoldChange', y='-log10Padj',
                hue='Significance',
                palette={'Upregulated':'green', 'Downregulated':'orange', 'Not Significant':'grey'},
                alpha=0.8)

plt.axvline(1, color='black', linestyle='--')
plt.axvline(-1, color='black', linestyle='--')
plt.xlabel("log2(Fold Change)")
plt.ylabel("-log10(Adjusted p-value)")
plt.title("Volcano Plot of Differentially Expressed Genes (Chr22)")
plt.legend(title='Significance')
plt.show()

import seaborn as sns
import pandas as pd

# Load the dataset from the uploaded file
df = pd.read_csv('breast cancer.txt')

print(df.head(5))

print(df.shape)

"""# **Scatter Plot**"""

import matplotlib.pyplot as plt
import seaborn as sns

plt.figure(figsize=(8, 6))
sns.scatterplot(data=df,
                x="radius_mean",
                y="texture_mean",
                hue="diagnosis")

"""## **Heatmap**"""

# Select the specified columns
selected_cols = [
    'radius_mean', 'texture_mean', 'perimeter_mean',
    'area_mean', 'smoothness_mean', 'compactness_mean'
]
df_subset = df[selected_cols]

# Compute the correlation matrix
corr_matrix = df_subset.corr()

# Create a heatmap of the correlation matrix
plt.figure(figsize=(10, 8))
sns.heatmap(corr_matrix, annot=True, cmap='Blues', fmt=".1f")

# Breast Cancer Diagnostic Data Visualization

# Import necessary libraries
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

# Import dataset from the provided URL

url = "https://raw.githubusercontent.com/HackBio-Internship/2025_project_collection/refs/heads/main/Python/Dataset/data-3.csv"

# Read the dataset directly from GitHub
data = pd.read_csv(url)

# Display the first 5 rows to confirm successful import
print(" Dataset successfully loaded!\n")
print(data.head())

# Basic info about the dataset

print(" \n Dataset Information:")
print(data.info())

# Check for missing values
print("\n Missing Values in Each Column:")
print(data.isnull().sum())

# Scatter Plot (Smoothness vs Compactness)
# Purpose:
# Visualize relationship between 'smoothness_mean' and 'compactness_mean'
# Color the data points based on the diagnosis (M = Malignant, B = Benign)

# Set a consistent Seaborn style
sns.set(style="whitegrid")

# Define figure size
plt.figure(figsize=(8,6))

# Create scatter plot
sns.scatterplot(
    data=data,
    x="compactness_mean",        # X-axis variable
    y="smoothness_mean",         # Y-axis variable
    hue="diagnosis",             # Color points by diagnosis type
    palette="Set1",              # Distinct colors for M and B
    s=70,                        # Size of scatter points
    edgecolor="black"            # Black border for clarity
)

# Add title and axis labels
plt.title("Scatter Plot: Smoothness vs Compactness", fontsize=14)
plt.xlabel("Compactness (Mean)", fontsize=12)
plt.ylabel("Smoothness (Mean)", fontsize=12)

# Add gridlines for better readability
plt.grid(True, linestyle="--", alpha=0.6)

# Show the plot
plt.show()

# Density Plot (Area Distribution)
# Purpose:
# Plot the distribution of 'area_mean' for both Malignant and Benign cases
# using smooth Kernel Density Estimates (KDE)

# Define figure size
plt.figure(figsize=(8,6))

# KDE for Malignant (M)
sns.kdeplot(
    data=data[data["diagnosis"] == "M"]["area_mean"],  # Subset only M cases
    label="Malignant",         # Label for the legend
    fill=True,                 # Fill area under curve
    alpha=0.5,                 # Transparency for overlap clarity
    linewidth=2
)

# KDE for Benign (B)
sns.kdeplot(
    data=data[data["diagnosis"] == "B"]["area_mean"],  # Subset only B cases
    label="Benign",            # Label for the legend
    fill=True,
    alpha=0.5,
    linewidth=2
)

# Add title, axis labels, and legend
plt.title("Density Plot of Area Mean by Diagnosis", fontsize=14)
plt.xlabel("Area (Mean)", fontsize=12)
plt.ylabel("Density", fontsize=12)
plt.legend(title="Diagnosis")

# Add gridlines for readability
plt.grid(True, linestyle="--", alpha=0.6)

# Display the plot
plt.show()